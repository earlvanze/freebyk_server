{"_id":"toposort","_rev":"23-c6164ba66d790a92c1d8999824016792","name":"toposort","description":"Topological sort of directed ascyclic graphs (like dependecy lists)","dist-tags":{"latest":"0.2.10"},"versions":{"0.1.0":{"name":"toposort","version":"0.1.0","description":"Topologically sort directed graphs (like dependecy lists)","main":"index.js","scripts":{"test":"echo \"Error: no test specified\" && exit 1"},"repository":{"type":"git","url":"https://github.com/marcelklehr/node-toposort.git"},"keywords":["topological","sort","sorting","graphs","graph","dependency","list","dependencies"],"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"license":"MIT","readmeFilename":"README.md","readme":"# Sort directed graphs\r\n\r\n## Example\r\nLet's say, you have a list of plugins, which depend on each other:\r\n```\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n```\r\n`depends` defines plugins that should be executed before the plugin that declares the directive.\r\n\r\nA quick analysis, will result in the following dependency (and thus execution) flow:\r\n\r\n```\r\nron\r\n - bar\r\n   - john\r\n     - tom\r\n   - foo\r\n```\r\n\r\nLet's try this with `toposort`:\r\n```\r\ntoposort = require('toposort')\r\n\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n\r\nvar result = toposort('name', 'depends', plugins)\r\n\r\n// we reverse the resulting list, because\r\n// toposort assumes ancestry, but we want descendancy\r\nconsole.dir(result.reverse())\r\n```\r\n\r\nOutput:\r\n```\r\n[ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n```\r\n\r\n## API\r\n\r\n### toposort(idProperty, ancestryProperty, list)\r\n * idProperty {String} The property of the objects in the `list`, which should be used as the identifier\r\n * ancestryProperty {String} The property of the objects in `list`, which should be used as the ancestry list\r\n * list {Array} A list of objects that have both properties.\r\n\r\nReturns a list of identifiers, sorted by their ancestry.\r\n\r\n## Legal\r\nMIT License","_id":"toposort@0.1.0","dist":{"shasum":"aaf3c3451b0ab9fba0e59d67953a89928c317267","tarball":"http://registry.npmjs.org/toposort/-/toposort-0.1.0.tgz"},"_npmVersion":"1.1.64","_npmUser":{"name":"marcelklehr","email":"mklehr@gmx.net"},"maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"directories":{}},"0.2.0":{"name":"toposort","version":"0.2.0","description":"Topological sort of directed ascyclic graphs (like dependecy lists)","main":"index.js","scripts":{"test":"node test.js"},"repository":{"type":"git","url":"https://github.com/marcelklehr/node-toposort.git"},"devDependencies":{"vows":"*"},"keywords":["topological","sort","sorting","graphs","graph","dependency","list","dependencies","acyclic"],"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"license":"MIT","readmeFilename":"README.md","readme":"# Sorting directed acyclic graphs\r\n[![Build Status](https://travis-ci.org/marcelklehr/beardless.png)](https://travis-ci.org/marcelklehr/beardless)\r\n\r\n## Installation\r\n`npm install toposort`\r\n\r\n## Example\r\nLet's say, you have a list of plugins, which depend on each other:\r\n```\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n```\r\n`depends` defines plugins that should be executed before the plugin that declares the directive.\r\n\r\nA quick analysis, will result in the following dependency tree:\r\n\r\n```\r\ntom\r\n |\r\njohn  foo\r\n |     |\r\n - - - - \r\n    |\r\n   bar\r\n    |\r\n   ron\r\n```\r\n\r\nand thus the following execution flow:\r\n\r\n```\r\n   ron\r\n    |\r\n   bar\r\n - - - - \r\n |     |\r\njohn  foo\r\n |\r\ntom\r\n```\r\n\r\nLet's try this with `toposort`:\r\n```\r\ntoposort = require('toposort')\r\n\r\nvar plugins =\r\n[ [\"foo\", 'bar']\r\n, [\"bar\", \"ron\"]\r\n, [\"john\", \"bar\"]\r\n, [\"tom\", \"john\"]\r\n]\r\n\r\nvar results = toposort(plugins)// this will output the dependency flow\r\nresults.reverse()// to get the resulting execution flow, we reverse the results\r\nconsole.dir(results)\r\n```\r\n\r\nOutput:\r\n```\r\n[ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n```\r\n\r\n## API\r\n\r\n### toposort(edges)\r\n * edges {Array} An array of edges like [node1, node2]\r\n\r\nReturns: {Array} a list of nodes, sorted by their dependency (following edge direction as descendancy)\r\n\r\n## Tests\r\nRun the tests with `node test.js`.\r\n\r\n## Legal\r\nMIT License","_id":"toposort@0.2.0","dist":{"shasum":"6e26f86ad707c18bdbdca3257dafec703d9364d7","tarball":"http://registry.npmjs.org/toposort/-/toposort-0.2.0.tgz"},"_npmVersion":"1.1.64","_npmUser":{"name":"marcelklehr","email":"mklehr@gmx.net"},"maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"directories":{}},"0.2.1":{"name":"toposort","version":"0.2.1","description":"Topological sort of directed ascyclic graphs (like dependecy lists)","main":"index.js","scripts":{"test":"node test.js"},"repository":{"type":"git","url":"https://github.com/marcelklehr/node-toposort.git"},"devDependencies":{"vows":"*"},"keywords":["topological","sort","sorting","graphs","graph","dependency","list","dependencies","acyclic"],"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"license":"MIT","readmeFilename":"README.md","readme":"# Sorting directed acyclic graphs\r\n[![Build Status](https://travis-ci.org/marcelklehr/node-toposort.png)](https://travis-ci.org/marcelklehr/node-toposort)\r\n\r\n## Installation\r\n`npm install toposort`\r\n\r\n## Example\r\nLet's say, you have a list of plugins, which depend on each other:\r\n```\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n```\r\n`depends` defines plugins that should be executed before the plugin that declares the directive.\r\n\r\nA quick analysis, will result in the following dependency tree:\r\n\r\n```\r\ntom\r\n |\r\njohn  foo\r\n |     |\r\n - - - - \r\n    |\r\n   bar\r\n    |\r\n   ron\r\n```\r\n\r\nand thus the following execution flow:\r\n\r\n```\r\n   ron\r\n    |\r\n   bar\r\n - - - - \r\n |     |\r\njohn  foo\r\n |\r\ntom\r\n```\r\n\r\nLet's try this with `toposort`:\r\n```\r\ntoposort = require('toposort')\r\n\r\nvar plugins =\r\n[ [\"foo\", 'bar']\r\n, [\"bar\", \"ron\"]\r\n, [\"john\", \"bar\"]\r\n, [\"tom\", \"john\"]\r\n]\r\n\r\nvar results = toposort(plugins)// this will output the dependency flow\r\nresults.reverse()// to get the resulting execution flow, we reverse the results\r\nconsole.dir(results)\r\n```\r\n\r\nOutput:\r\n```\r\n[ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n```\r\n\r\n## API\r\n\r\n### toposort(edges)\r\n * edges {Array} An array of edges like [node1, node2]\r\n\r\nReturns: {Array} a list of nodes, sorted by their dependency (following edge direction as descendancy)\r\n\r\n## Tests\r\nRun the tests with `node test.js`.\r\n\r\n## Legal\r\nMIT License","_id":"toposort@0.2.1","dist":{"shasum":"0d8997a20e0f54ea2f986ba764bc741b48a38f0e","tarball":"http://registry.npmjs.org/toposort/-/toposort-0.2.1.tgz"},"_npmVersion":"1.1.64","_npmUser":{"name":"marcelklehr","email":"mklehr@gmx.net"},"maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"directories":{}},"0.2.2":{"name":"toposort","version":"0.2.2","description":"Topological sort of directed ascyclic graphs (like dependecy lists)","main":"index.js","scripts":{"test":"node test.js"},"repository":{"type":"git","url":"https://github.com/marcelklehr/node-toposort.git"},"devDependencies":{"vows":"*"},"keywords":["topological","sort","sorting","graphs","graph","dependency","list","dependencies","acyclic"],"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"license":"MIT","readmeFilename":"README.md","readme":"# Sorting directed acyclic graphs\r\n[![Build Status](https://travis-ci.org/marcelklehr/node-toposort.png)](https://travis-ci.org/marcelklehr/node-toposort)\r\n\r\n## Installation\r\n`npm install toposort`\r\n\r\n## Example\r\nLet's say, you have a list of pluginsor tasks, which depend on each other (`depends` defines plugins or tasks that should be executed before the plugin that declares the directive):\r\n\r\n```\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n```\r\n\r\nA quick analysis, will result in the following dependency tree:\r\n\r\n```\r\ntom\r\n |\r\njohn  foo\r\n |     |\r\n - - - - \r\n    |\r\n   bar\r\n    |\r\n   ron\r\n```\r\n\r\nand thus the following execution flow:\r\n\r\n```\r\n   ron\r\n    |\r\n   bar\r\n - - - - \r\n |     |\r\njohn  foo\r\n |\r\ntom\r\n```\r\n\r\nLet's try this with `toposort`:\r\n\r\n```js\r\ntoposort = require('toposort')\r\n\r\nvar plugins =\r\n[ [\"foo\", 'bar']\r\n, [\"bar\", \"ron\"]\r\n, [\"john\", \"bar\"]\r\n, [\"tom\", \"john\"]\r\n]\r\n\r\n// this will sort our plugins by dependecy\r\nvar results = toposort(plugins)\r\n\r\n// now, we reverse the results to get the resulting execution flow, as above\r\nresults.reverse()\r\n\r\nconsole.dir(results)\r\n/*\r\nOutput:\r\n\r\n[ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n\r\n*/\r\n```\r\n\r\n## API\r\n\r\n### toposort(edges)\r\n * edges {Array} An array of directed vertices like `[node1, node2]` (where `node1` depends on `node2`)\r\n\r\nReturns: {Array} a list of nodes, sorted by their dependency (following edge direction as descendancy)\r\n\r\n## Tests\r\nRun the tests with `node test.js`.\r\n\r\n## Legal\r\nMIT License","_id":"toposort@0.2.2","dist":{"shasum":"e3a5717763d269427e4395464ed98653f99cd915","tarball":"http://registry.npmjs.org/toposort/-/toposort-0.2.2.tgz"},"_npmVersion":"1.1.64","_npmUser":{"name":"marcelklehr","email":"mklehr@gmx.net"},"maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"directories":{}},"0.2.3":{"name":"toposort","version":"0.2.3","description":"Topological sort of directed ascyclic graphs (like dependecy lists)","main":"index.js","scripts":{"test":"node test.js"},"repository":{"type":"git","url":"https://github.com/marcelklehr/node-toposort.git"},"devDependencies":{"vows":"*"},"keywords":["topological","sort","sorting","graphs","graph","dependency","list","dependencies","acyclic"],"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"license":"MIT","readmeFilename":"README.md","readme":"# Sorting directed acyclic graphs\r\n[![Build Status](https://travis-ci.org/marcelklehr/node-toposort.png)](https://travis-ci.org/marcelklehr/node-toposort)\r\n\r\n## Installation\r\n`npm install toposort`\r\n\r\n## Example\r\nLet's say, you have a list of pluginsor tasks, which depend on each other (`depends` defines plugins or tasks that should be executed before the plugin that declares the directive):\r\n\r\n```\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n```\r\n\r\nA quick analysis, will result in the following dependency tree:\r\n\r\n```\r\ntom\r\n |\r\njohn  foo\r\n |     |\r\n - - - - \r\n    |\r\n   bar\r\n    |\r\n   ron\r\n```\r\n\r\nand thus the following execution flow:\r\n\r\n```\r\n   ron\r\n    |\r\n   bar\r\n - - - - \r\n |     |\r\njohn  foo\r\n |\r\ntom\r\n```\r\n\r\nLet's try this with `toposort`:\r\n\r\n```js\r\ntoposort = require('toposort')\r\n\r\nvar plugins =\r\n[ [\"foo\", 'bar']\r\n, [\"bar\", \"ron\"]\r\n, [\"john\", \"bar\"]\r\n, [\"tom\", \"john\"]\r\n]\r\n\r\n// this will sort our plugins by dependecy\r\nvar results = toposort(plugins)\r\n\r\n// now, we reverse the results to get the resulting execution flow, as above\r\nresults.reverse()\r\n\r\nconsole.dir(results)\r\n/*\r\nOutput:\r\n\r\n[ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n\r\n*/\r\n```\r\n\r\n## API\r\n\r\n### toposort(edges)\r\n * edges {Array} An array of directed vertices like `[node1, node2]` (where `node1` depends on `node2`)\r\n\r\nReturns: {Array} a list of nodes, sorted by their dependency (following edge direction as descendancy)\r\n\r\n## Tests\r\nRun the tests with `node test.js`.\r\n\r\n## Legal\r\nMIT License","_id":"toposort@0.2.3","dist":{"shasum":"21cdf2d4690763378b5d175f4e4f30ed4ad39d7c","tarball":"http://registry.npmjs.org/toposort/-/toposort-0.2.3.tgz"},"_npmVersion":"1.1.68","_npmUser":{"name":"marcelklehr","email":"mklehr@gmx.net"},"maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"directories":{}},"0.2.4":{"name":"toposort","version":"0.2.4","description":"Topological sort of directed ascyclic graphs (like dependecy lists)","main":"index.js","scripts":{"test":"node test.js"},"repository":{"type":"git","url":"https://github.com/marcelklehr/node-toposort.git"},"devDependencies":{"vows":"*"},"keywords":["topological","sort","sorting","graphs","graph","dependency","list","dependencies","acyclic"],"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"license":"MIT","readmeFilename":"README.md","readme":"# Sorting directed acyclic graphs\r\n[![Build Status](https://travis-ci.org/marcelklehr/node-toposort.png)](https://travis-ci.org/marcelklehr/node-toposort)\r\n\r\n## Installation\r\n`npm install toposort`\r\n\r\n## Example\r\nLet's say, you have a list of plugins or tasks, which depend on each other (`depends` defines plugins or tasks that should be executed before the plugin that declares the directive):\r\n\r\n```\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n```\r\n\r\nA quick analysis, will result in the following dependency tree:\r\n\r\n```\r\ntom\r\n |\r\njohn  foo\r\n |     |\r\n - - - - \r\n    |\r\n   bar\r\n    |\r\n   ron\r\n```\r\n\r\nand thus the following execution flow:\r\n\r\n```\r\n   ron\r\n    |\r\n   bar\r\n - - - - \r\n |     |\r\njohn  foo\r\n |\r\ntom\r\n```\r\n\r\nLet's try this with `toposort`:\r\n\r\n```js\r\ntoposort = require('toposort')\r\n\r\nvar plugins =\r\n[ [\"foo\", 'bar']\r\n, [\"bar\", \"ron\"]\r\n, [\"john\", \"bar\"]\r\n, [\"tom\", \"john\"]\r\n]\r\n\r\n// this will sort our plugins by dependecy\r\nvar results = toposort(plugins)\r\n\r\n// now, we reverse the results to get the resulting execution flow, as above\r\nresults.reverse()\r\n\r\nconsole.dir(results)\r\n/*\r\nOutput:\r\n\r\n[ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n\r\n*/\r\n```\r\n\r\n## API\r\n\r\n### toposort(edges)\r\n * edges {Array} An array of directed vertices like `[node1, node2]` (where `node1` depends on `node2`) -- these needn't be strings but can be any of any type\r\n\r\nReturns: {Array} a list of nodes, sorted by their dependency (following edge direction as descendancy)\r\n\r\n## Tests\r\nRun the tests with `node test.js`.\r\n\r\n## Legal\r\nMIT License","_id":"toposort@0.2.4","dist":{"shasum":"70714e487ce5bf3b3afdea8c80ccb77d3ec9b2d0","tarball":"http://registry.npmjs.org/toposort/-/toposort-0.2.4.tgz"},"_npmVersion":"1.1.68","_npmUser":{"name":"marcelklehr","email":"mklehr@gmx.net"},"maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"directories":{}},"0.2.5":{"name":"toposort","version":"0.2.5","description":"Topological sort of directed ascyclic graphs (like dependecy lists)","main":"index.js","scripts":{"test":"node test.js"},"repository":{"type":"git","url":"https://github.com/marcelklehr/node-toposort.git"},"devDependencies":{"vows":"*"},"keywords":["topological","sort","sorting","graphs","graph","dependency","list","dependencies","acyclic"],"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"license":"MIT","readmeFilename":"README.md","readme":"# Sorting directed acyclic graphs\r\n[![Build Status](https://travis-ci.org/marcelklehr/node-toposort.png)](https://travis-ci.org/marcelklehr/node-toposort)\r\n\r\n## Installation\r\n`npm install toposort`\r\n\r\n## Example\r\nLet's say, you have a list of plugins or tasks, which depend on each other (`depends` defines plugins or tasks that should be executed before the plugin that declares the directive):\r\n\r\n```\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n```\r\n\r\nA quick analysis, will result in the following dependency tree:\r\n\r\n```\r\ntom\r\n |\r\njohn  foo\r\n |     |\r\n - - - - \r\n    |\r\n   bar\r\n    |\r\n   ron\r\n```\r\n\r\nand thus the following execution flow:\r\n\r\n```\r\n   ron\r\n    |\r\n   bar\r\n - - - - \r\n |     |\r\njohn  foo\r\n |\r\ntom\r\n```\r\n\r\nLet's try this with `toposort`:\r\n\r\n```js\r\ntoposort = require('toposort')\r\n\r\nvar plugins =\r\n[ [\"foo\", 'bar']\r\n, [\"bar\", \"ron\"]\r\n, [\"john\", \"bar\"]\r\n, [\"tom\", \"john\"]\r\n]\r\n\r\n// this will sort our plugins by dependecy\r\nvar results = toposort(plugins)\r\n\r\n// now, we reverse the results to get the resulting execution flow, as above\r\nresults.reverse()\r\n\r\nconsole.dir(results)\r\n/*\r\nOutput:\r\n\r\n[ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n\r\n*/\r\n```\r\n\r\n## API\r\n\r\n### toposort(edges)\r\n * edges {Array} An array of directed vertices like `[node1, node2]` (where `node1` depends on `node2`) -- these needn't be strings but can be any of any type\r\n\r\nReturns: {Array} a list of nodes, sorted by their dependency (following edge direction as descendancy)\r\n\r\n## Tests\r\nRun the tests with `node test.js`.\r\n\r\n## Legal\r\nMIT License","_id":"toposort@0.2.5","dist":{"shasum":"ea5a4327ff00cf555451d15cfb38ec1c881d4edb","tarball":"http://registry.npmjs.org/toposort/-/toposort-0.2.5.tgz"},"_npmVersion":"1.1.68","_npmUser":{"name":"marcelklehr","email":"mklehr@gmx.net"},"maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"directories":{}},"0.2.7":{"name":"toposort","version":"0.2.7","description":"Topological sort of directed ascyclic graphs (like dependecy lists)","main":"index.js","scripts":{"test":"node test.js"},"repository":{"type":"git","url":"https://github.com/marcelklehr/toposort.git"},"devDependencies":{"vows":"*"},"keywords":["topological","sort","sorting","graphs","graph","dependency","list","dependencies","acyclic"],"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"license":"MIT","readmeFilename":"README.md","readme":"# Sorting directed acyclic graphs\r\n[![Build Status](https://travis-ci.org/marcelklehr/toposort.png)](https://travis-ci.org/marcelklehr/toposort)\r\n\r\n## Installation\r\n`npm install toposort` or `component install toposort`\r\n\r\n## Example\r\nLet's say, you have a list of plugins or tasks, which depend on each other (`depends` defines plugins or tasks that should be executed before the plugin that declares the directive):\r\n\r\n```\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n```\r\n\r\nA quick analysis, will result in the following dependency tree:\r\n\r\n```\r\ntom\r\n |\r\njohn  foo\r\n |     |\r\n - - - - \r\n    |\r\n   bar\r\n    |\r\n   ron\r\n```\r\n\r\nand thus the following execution flow:\r\n\r\n```\r\n   ron\r\n    |\r\n   bar\r\n - - - - \r\n |     |\r\njohn  foo\r\n |\r\ntom\r\n```\r\n\r\nLet's try this with `toposort`:\r\n\r\n```js\r\ntoposort = require('toposort')\r\n\r\nvar plugins =\r\n[ [\"foo\", 'bar']\r\n, [\"bar\", \"ron\"]\r\n, [\"john\", \"bar\"]\r\n, [\"tom\", \"john\"]\r\n]\r\n\r\n// this will sort our plugins by dependecy\r\nvar results = toposort(plugins)\r\n\r\n// now, we reverse the results to get the resulting execution flow, as above\r\nresults.reverse()\r\n\r\nconsole.dir(results)\r\n/*\r\nOutput:\r\n\r\n[ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n\r\n*/\r\n```\r\n\r\n## API\r\n\r\n### toposort(edges)\r\n * edges {Array} An array of directed vertices like `[node1, node2]` (where `node1` depends on `node2`) -- these needn't be strings but can be any of any type\r\n\r\nReturns: {Array} a list of nodes, sorted by their dependency (following edge direction as descendancy)\r\n\r\n## Tests\r\nRun the tests with `node test.js`.\r\n\r\n## Legal\r\nMIT License","_id":"toposort@0.2.7","dist":{"shasum":"3d8e0b6f7d90bc7b30b93b0e90724fa1dde66a76","tarball":"http://registry.npmjs.org/toposort/-/toposort-0.2.7.tgz"},"_from":".","_npmVersion":"1.2.11","_npmUser":{"name":"marcelklehr","email":"mklehr@gmx.net"},"maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"directories":{}},"0.2.8":{"name":"toposort","version":"0.2.8","description":"Topological sort of directed ascyclic graphs (like dependecy lists)","main":"index.js","scripts":{"test":"node test.js"},"repository":{"type":"git","url":"https://github.com/marcelklehr/toposort.git"},"devDependencies":{"vows":"*"},"keywords":["topological","sort","sorting","graphs","graph","dependency","list","dependencies","acyclic"],"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"license":"MIT","readmeFilename":"README.md","readme":"# Sorting directed acyclic graphs\r\n[![Build Status](https://travis-ci.org/marcelklehr/toposort.png)](https://travis-ci.org/marcelklehr/toposort)\r\n\r\n## Installation\r\n`npm install toposort` or `component install toposort`\r\n\r\n## Example\r\nLet's say, you have a list of plugins or tasks, which depend on each other (`depends` defines plugins or tasks that should be executed before the plugin that declares the directive):\r\n\r\n```\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n```\r\n\r\nA quick analysis, will result in the following dependency tree:\r\n\r\n```\r\ntom\r\n |\r\njohn  foo\r\n |     |\r\n - - - - \r\n    |\r\n   bar\r\n    |\r\n   ron\r\n```\r\n\r\nand thus the following execution flow:\r\n\r\n```\r\n   ron\r\n    |\r\n   bar\r\n - - - - \r\n |     |\r\njohn  foo\r\n |\r\ntom\r\n```\r\n\r\nLet's try this with `toposort`:\r\n\r\n```js\r\ntoposort = require('toposort')\r\n\r\nvar plugins =\r\n[ [\"foo\", 'bar']\r\n, [\"bar\", \"ron\"]\r\n, [\"john\", \"bar\"]\r\n, [\"tom\", \"john\"]\r\n]\r\n\r\n// this will sort our plugins by dependecy\r\nvar results = toposort(plugins)\r\n\r\n// now, we reverse the results to get the resulting execution flow, as above\r\nresults.reverse()\r\n\r\nconsole.dir(results)\r\n/*\r\nOutput:\r\n\r\n[ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n\r\n*/\r\n```\r\n\r\n## API\r\n\r\n### toposort(edges)\r\n * edges {Array} An array of directed vertices like `[node1, node2]` (where `node1` depends on `node2`) -- these needn't be strings but can be any of any type\r\n\r\nReturns: {Array} a list of nodes, sorted by their dependency (following edge direction as descendancy)\r\n\r\n## Tests\r\nRun the tests with `node test.js`.\r\n\r\n## Legal\r\nMIT License","_id":"toposort@0.2.8","dist":{"shasum":"1a3f2f0a3432c06338f67e4e732a28ce8d3f207b","tarball":"http://registry.npmjs.org/toposort/-/toposort-0.2.8.tgz"},"_from":".","_npmVersion":"1.2.11","_npmUser":{"name":"marcelklehr","email":"mklehr@gmx.net"},"maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"directories":{}},"0.2.9":{"name":"toposort","version":"0.2.9","description":"Topological sort of directed ascyclic graphs (like dependecy lists)","main":"index.js","scripts":{"test":"node test.js"},"repository":{"type":"git","url":"https://github.com/marcelklehr/toposort.git"},"devDependencies":{"vows":"*"},"keywords":["topological","sort","sorting","graphs","graph","dependency","list","dependencies","acyclic"],"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"license":"MIT","readmeFilename":"README.md","readme":"# Toposort\r\n\r\nSort directed acyclic graphs\r\n\r\n[![Build Status](https://travis-ci.org/marcelklehr/toposort.png)](https://travis-ci.org/marcelklehr/toposort)\r\n\r\n## Installation\r\n\r\n`npm install toposort` or `component install marcelklehr/toposort`  \r\n\r\nthen in your code:\r\n\r\n```js\r\ntoposort = require('toposort')\r\n```\r\n\r\n## Example\r\n\r\nLet's say you are compiling a project consisting of 5 modules. You know there are some dependencies between them so you want to figure a safe execution order to run them in. Lets assume we have tool which spits out dependency data for us:\r\n\r\n```\r\nvar project = [\r\n  {name: \"foo\", depends: ['bar']},\r\n  {name: \"bar\", depends: [\"ron\"]},\r\n  {name: \"john\", depends: [\"bar\"]},\r\n  {name: \"tom\", depends: [\"john\"]},\r\n  {name: \"ron\", depends: []}\r\n]\r\n```\r\n\r\nWhich if visualized in a graph:\r\n\r\n![graph](out.png)\r\n\r\nreveals two safe execution orders:\r\n\r\n+ `ron -> bar -> foo -> john -> tom`\r\n+ `ron -> bar -> john -> tom -> foo`\r\n\r\nLet's see if we can get `toposort` to figure that out for us. First though we need to translate the dependency information into something it can understand. The way `toposort` understands relationships is with edges. An \"edge\" is a 2 item `Array` where the first item is the subject and the 2nd item is the target.  \r\n\r\nWith edges our data looks like this: \r\n\r\n```js\r\nvar modules = [\r\n  [\"foo\", \"bar\"],\r\n  [\"bar\", \"ron\"],\r\n  [\"john\", \"bar\"],\r\n  [\"tom\", \"john\"]\r\n]\r\n```\r\n\r\nRunning it through `toposort` we get:\r\n\r\n```js\r\nvar results = toposort(modules)\r\n\r\nconsole.dir(results)\r\n// => [ 'tom', 'john', 'foo', 'bar', 'ron' ]\r\n```\r\nSo `toposort` prefered the first path through the graph. Since it was the first it encountered.\r\n\r\nNow, we to get the best execution order, we can just reverse the returned array:\r\n\r\n```js\r\nconsole.dir(results.reverse())\r\n// => [ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n```\r\n\r\n## API\r\n\r\n### toposort(edges)\r\n\r\n+ edges {Array} An array of directed vertices like `[node1, node2]` (where `node1` depends on `node2`) -- these needn't be strings but can be of any type\r\n\r\nReturns: {Array} a list of nodes, sorted from least dependencies to most\r\n\r\n## Tests\r\n\r\nRun the tests with `node test.js`.\r\n\r\n## Legal\r\n\r\nMIT License","_id":"toposort@0.2.9","dist":{"shasum":"ba40039840b42f6ef7597f6683d98234655bcc17","tarball":"http://registry.npmjs.org/toposort/-/toposort-0.2.9.tgz"},"_from":".","_npmVersion":"1.2.15","_npmUser":{"name":"marcelklehr","email":"mklehr@gmx.net"},"maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"directories":{}},"0.2.10":{"name":"toposort","version":"0.2.10","description":"Topological sort of directed ascyclic graphs (like dependecy lists)","main":"index.js","scripts":{"test":"node test.js"},"repository":{"type":"git","url":"https://github.com/marcelklehr/toposort.git"},"devDependencies":{"vows":"*"},"keywords":["topological","sort","sorting","graphs","graph","dependency","list","dependencies","acyclic"],"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"license":"MIT","readmeFilename":"README.md","readme":"# Toposort\r\n\r\nSort directed acyclic graphs\r\n\r\n[![Build Status](https://travis-ci.org/marcelklehr/toposort.png)](https://travis-ci.org/marcelklehr/toposort)\r\n\r\n## Installation\r\n\r\n`npm install toposort` or `component install marcelklehr/toposort`  \r\n\r\nthen in your code:\r\n\r\n```js\r\ntoposort = require('toposort')\r\n```\r\n\r\n## Example\r\n\r\nLet's say you are compiling a project consisting of 5 modules. You know there are some dependencies between them so you want to figure a safe execution order to run them in. Lets assume we have tool which spits out dependency data for us:\r\n\r\n```\r\nvar project = [\r\n  {name: \"foo\", depends: ['bar']},\r\n  {name: \"bar\", depends: [\"ron\"]},\r\n  {name: \"john\", depends: [\"bar\"]},\r\n  {name: \"tom\", depends: [\"john\"]},\r\n  {name: \"ron\", depends: []}\r\n]\r\n```\r\n\r\nWhich if visualized in a graph:\r\n\r\n![graph](out.png)\r\n\r\nreveals two safe execution orders:\r\n\r\n+ `ron -> bar -> foo -> john -> tom`\r\n+ `ron -> bar -> john -> tom -> foo`\r\n\r\nLet's see if we can get `toposort` to figure that out for us. First though we need to translate the dependency information into something it can understand. The way `toposort` understands relationships is with edges. An \"edge\" is a 2 item `Array` where the first item is the subject and the 2nd item is the target.  \r\n\r\nWith edges our data looks like this: \r\n\r\n```js\r\nvar modules = [\r\n  [\"foo\", \"bar\"],\r\n  [\"bar\", \"ron\"],\r\n  [\"john\", \"bar\"],\r\n  [\"tom\", \"john\"]\r\n]\r\n```\r\n\r\nRunning it through `toposort` we get:\r\n\r\n```js\r\nvar results = toposort(modules)\r\n\r\nconsole.dir(results)\r\n// => [ 'tom', 'john', 'foo', 'bar', 'ron' ]\r\n```\r\nSo `toposort` prefered the first path through the graph. Since it was the first it encountered.\r\n\r\nNow, we to get the best execution order, we can just reverse the returned array:\r\n\r\n```js\r\nconsole.dir(results.reverse())\r\n// => [ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n```\r\n\r\n## API\r\n\r\n### toposort(edges)\r\n\r\n+ edges {Array} An array of directed vertices like `[node1, node2]` (where `node1` depends on `node2`) -- these needn't be strings but can be of any type\r\n\r\nReturns: {Array} a list of nodes, sorted from least dependencies to most\r\n\r\n### toposort.array(nodes, edges)\r\n\r\n+ nodes {Array} An array of nodes\r\n+ edges {Array} As with `toposort`. Edges doesn't necessarily need to contain all the items in `nodes`. However, the ordering of the items you don't mention will be undefined.\r\n\r\nReturns: {Array} as per `toposort`\r\n\r\n## Tests\r\n\r\nRun the tests with `node test.js`.\r\n\r\n## Legal\r\n\r\nMIT License","bugs":{"url":"https://github.com/marcelklehr/toposort/issues"},"_id":"toposort@0.2.10","dist":{"shasum":"bd86f4bb2408307d1912ba6aacbd01790a64fd2c","tarball":"http://registry.npmjs.org/toposort/-/toposort-0.2.10.tgz"},"_from":".","_npmVersion":"1.3.7","_npmUser":{"name":"marcelklehr","email":"mklehr@gmx.net"},"maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"directories":{}}},"readme":"# Sort directed graphs\r\n\r\n## Example\r\nLet's say, you have a list of plugins, which depend on each other:\r\n```\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n```\r\n`depends` defines plugins that should be executed before the plugin that declares the directive.\r\n\r\nA quick analysis, will result in the following dependency (and thus execution) flow:\r\n\r\n```\r\nron\r\n - bar\r\n   - john\r\n     - tom\r\n   - foo\r\n```\r\n\r\nLet's try this with `toposort`:\r\n```\r\ntoposort = require('toposort')\r\n\r\nvar plugins =\r\n[ {name: \"foo\", depends: ['bar']}\r\n, {name: \"bar\", depends: [\"ron\"]}\r\n, {name: \"john\", depends: [\"bar\"]}\r\n, {name: \"tom\", depends: [\"john\"]}\r\n, {name: \"ron\", depends: []}\r\n]\r\n\r\nvar result = toposort('name', 'depends', plugins)\r\n\r\n// we reverse the resulting list, because\r\n// toposort assumes ancestry, but we want descendancy\r\nconsole.dir(result.reverse())\r\n```\r\n\r\nOutput:\r\n```\r\n[ 'ron', 'bar', 'foo', 'john', 'tom' ]\r\n```\r\n\r\n## API\r\n\r\n### toposort(idProperty, ancestryProperty, list)\r\n * idProperty {String} The property of the objects in the `list`, which should be used as the identifier\r\n * ancestryProperty {String} The property of the objects in `list`, which should be used as the ancestry list\r\n * list {Array} A list of objects that have both properties.\r\n\r\nReturns a list of identifiers, sorted by their ancestry.\r\n\r\n## Legal\r\nMIT License","maintainers":[{"name":"marcelklehr","email":"mklehr@gmx.net"}],"time":{"modified":"2013-09-15T10:24:16.847Z","created":"2012-11-02T14:21:23.712Z","0.1.0":"2012-11-02T14:21:26.533Z","0.2.0":"2012-11-04T14:12:50.950Z","0.2.1":"2012-11-04T14:14:38.755Z","0.2.2":"2012-11-04T19:14:46.213Z","0.2.3":"2013-01-27T19:30:50.983Z","0.2.4":"2013-01-27T19:41:22.833Z","0.2.5":"2013-02-08T21:03:45.797Z","0.2.7":"2013-02-17T15:16:00.267Z","0.2.8":"2013-02-19T15:56:21.821Z","0.2.9":"2013-04-10T10:22:40.827Z","0.2.10":"2013-09-15T10:24:16.847Z"},"author":{"name":"Marcel Klehr","email":"mklehr@gmx.net"},"repository":{"type":"git","url":"https://github.com/marcelklehr/toposort.git"},"_attachments":{},"_etag":"\"7PJGCR52VPZ0L6VU4XLBN4JMX\""}